<link rel="import" href="../../../polymer/polymer.html">
<link rel="import" href="../../../iron-ajax/iron-ajax.html">
<link rel="import" href="../../../aeris-metadata-components/dist/aeris-metadata-international-field/aeris-metadata-international-field.html">
<link rel="import" href="../../../aeris-commons-components/dist/imports/openlayers3.html">
<link rel="import" href="../../../aeris-commons-components/dist/imports/font-awesome.html">
<link rel="import" href="../../../aeris-commons-components/dist/styles/catalog-shared-styles.html">
<link rel="import" href="../../../aeris-commons-components/dist/behaviors/i18n/localizeBehavior.html">
<link rel="import" href="../../../aeris-commons-components/dist/imports/custom-scrollbar.html">

<dom-module id="aeris-catalog-map">

 <style is="custom-style">
    :host {
        display: block;
        position: relative;
        overflow: hidden;
        background-color: #fff
    }
    :host .map-container {
        position: relative;
        height: 100%;
        opacity: 1;
        transition: 0.3s
    }
    :host .map-container .map {
        box-sizing: border-box;
        width: 100%;
        height: 100%;
        background-color: #2D4059;
        transition: 0.3s
    }
    :host .map-container:hover .map-coordinates {
        opacity: 1
    }
    :host .map-container .map-mask {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #fff
    }
    :host .viewport {
        opacity: 0;
        transition: 0.6s
    }
    :host .map.reduced {
        padding-right: 300px
    }
    :host .map.reduced ~ .map-coordinates {
        right: 305px
    }
    :host aeris-spinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        --spinner-main-color: #333
    }
    :host .feature-info-tooltip {
        position: absolute;
        max-width: 300px;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 5px 10px;
        color: #333;
        font-size: 12px;
        border: 1px solid;
        border-radius: 3px;
        transform: scaleX(1);
        opacity: 1;
        transform-origin: 0 50%;
        transition: opacity 0.3s, transform 0.3s
    }
    :host .feature-info-tooltip h4 {
        margin: 0
    }
    :host .feature-info-tooltip ul {
        margin: 3px 0 0;
        padding-left: 15px
    }
    :host .feature-info-tooltip.hidden {
        transform: scaleX(0);
        opacity: 0;
        transition: 0s
    }
    :host .map-coordinates {
        display: block;
        opacity: 0;
        width: 120px;
        background-color: rgba(0, 0, 0, 0.6);
        position: absolute;
        bottom: 5px;
        right: 5px;
        padding: 5px;
        font-size: 12px;
        color: #fff;
        text-align: center
    }
</style>

  <template>

    <iron-ajax id="ajax"
                 url=""
                 params=''
                 handle-as="json"
                 on-response="_handleResponse"
                 on-error="_handleError"
                 debounce-duration="300"
                 headers='{"cache-control": "max-age=10"}'>
    </iron-ajax>
    <div class="map-container">
      <div id="mapMask" class="map-mask"></div>
      <div id="map" class="map" tabindex="0"></div>
      <div id="mapCoordinates" class="map-coordinates"></div>
      <content></content>
    </div>
    <div id="info" class="feature-info-tooltip">
      <h4>[[tooltipText.name]]</h4>
      <section hidden$="[[!tooltipText.description]]">
        <aeris-metadata-international-field label="[[_localize('title', lang)]]" value="[[tooltipText.description]]" lang="[[lang]]" no-label-float></aeris-metadata-international-field>
      </section>
      <section hidden$="[[!tooltipText.additionalData]]">
        <ul>
          <template is="dom-repeat" items="[[_toArray(tooltipText.additionalData)]]" filter="_isNotId">
            <li>[[item.name]]: [[item.value]]</li>
          </template>
        </ul>
      </section>
    </div>
  </template>

  <script>

    const FADEIN_DURATION = 1000; /* milliseconds */
    const DEFAULT_ZOOM = 2;
   // const DEFAULT_CENTER = ol.proj.transform([0, 0], 'EPSG:4326', 'EPSG:900913'); /* [long, lat] */
    const EXTENTS_COLOR = '#e74c3c';

    Polymer({

      is: 'aeris-catalog-map',

      behaviors: [LocalizeBehavior],

      properties: {
        service: String,
        _isPreviewCleared: {type: Boolean, value: true},
        _isDrawMode: {type: Boolean, value: false},
        lang: {type: String, reflectToAttribute: true, observer: 'attached'},
        area: {type: Object, reflectToAttribute: true}
      },

      ready: function() {
        /* Handle editing spatial extent on map */
        document.addEventListener('mapEditStartEvent', this._handleMapEditStartEvent.bind(this));
        document.addEventListener('mapEditStopEvent', this._handleMapEditStopEvent.bind(this));

        /* Handle click on the 'reset' button */
        document.addEventListener('searchBarResetEvent', this._handleSearchBarResetEvent.bind(this));

        /* Clear the user selection drew on map  */
        document.addEventListener('mapClearSelectionRequest', this._handleMapClearSelectionEvent.bind(this));

        /* Clear all features on the map */
        document.addEventListener('mapClearAllFeaturesRequest', this._handleMapClearAllFeaturesEvent.bind(this));

        /* Clear all features except the one drew by the user */
        document.addEventListener('mapClearFeaturesRequest', this._removeAllButSelectionBox.bind(this));

        /* Clear all previews on the map */
        document.addEventListener('mapClearPreviewRequest', this._clearPreview.bind(this));

        /* Handle the user spatial extent */
        document.addEventListener('mapAddSelectionRequest', this._handlemapAddSelectionRequest.bind(this));

        /* Add features on map */
        document.addEventListener('mapAddFeaturesRequest', this._handlemapAddFeaturesRequest.bind(this));

        /* Add previews on map */
        document.addEventListener('mapAddPreviewRequest', this._handlemapAddPreviewRequest.bind(this));

        /* Handle search request to the web-service */
        document.addEventListener('metadataRequest', this._handlemapMetadataRequest.bind(this));
      },

      attached: function() {
        var _this = this;
        this.updateLang();

        if(this._map) return;

        /* Map background */
        var raster = new ol.layer.Tile({
          source: new ol.source.XYZ({
            url: 'https://api.mapbox.com/v4/mapbox.streets-satellite/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoiZnJhbmNvaXNhbmRyZSIsImEiOiJjaXVlMGE5b3QwMDBoMm9tZGQ1M2xubzVhIn0.FK8gRVJb4ADNnrO6cNlWUw'
            // url: 'http://api.tiles.mapbox.com/v4/mapbox.satellite/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoiZnJhbmNvaXNhbmRyZSIsImEiOiJjaXVlMGE5b3QwMDBoMm9tZGQ1M2xubzVhIn0.FK8gRVJb4ADNnrO6cNlWUw'
          })
        });

        /* Create map sources */
        this.initialiseMainSource();
        this.initialisePreviewSource();

        /* Initialise map */
        this._map = new ol.Map({
          layers: [raster, this._vector, this.mainClusteredLayer],
          target: this.$.map,
          controls: ol.control.defaults({attribution: false}),
          view:  new ol.View({
            center: DEFAULT_CENTER,
            zoom: DEFAULT_ZOOM,
            maxZoom: 18,
            minZoom: 0,
          })
        });

        /* Add layers */
        this._map.addLayer(this.previewLayer);
        this._map.addLayer(this.previewClusteredLayer);

        /* Hide map and fade in when loaded */
        var mapViewport = this.$.map.querySelector('.ol-viewport');
        mapViewport.style.opacity = 0;

        raster.getSource().on('tileloadend', function() {
          var mapZoom = mapViewport.querySelector('.ol-zoom');
          mapZoom.style.top = 'auto';
          mapZoom.style.bottom = '0.5em';

          window.setTimeout(function() {
            mapViewport.style.transition = FADEIN_DURATION / 1000 + 's';
            mapViewport.style.opacity = 1;

            window.setTimeout(function() {
              _this.$.mapMask.style.display = 'none';
            }, (FADEIN_DURATION + 100));
            
          }, 500);

        });

        /* --- Tooltip related --- */
        this._map.on('pointermove', function(e) {
          var info = this.$.info;
          if (e.dragging) {
            info.classList.add('hidden');
            return;
          }

          var pixel = this._map.getEventPixel(e.originalEvent);

          var feature = this._map.forEachFeatureAtPixel(pixel, function(feature) {
            return feature;
          });

          if(feature) {
            info.style.cssText = 'left:' + (pixel[0] + 10) + 'px;top:' + (pixel[1] - 15) + 'px';

            if(feature.get('features')) {
              var features = feature.get('features');
              var size = features.length;
              
              if(size === 1) {
                this._displayFeatureInfo(features[0]);
              }
              
            } else {
              this._displayFeatureInfo(feature);
            }

          } else {
            document.body.style.cursor = 'default';
            info.classList.add('hidden');
          }

        }.bind(this));

        this._map.on('click', function(e) {
          var feature = this._map.forEachFeatureAtPixel(e.pixel, function(feature) {
            return feature;
          });

          if(feature) {
            info.style.cssText = 'left:' + (e.pixel[0] + 10) + 'px;top:' + (e.pixel[1] - 15) + 'px';
            this._displayFeatureInfo(feature);
          } else {
            info.classList.add('hidden');
          }
        }.bind(this));

        /* --- End Tooltip functions --- */

        this._map.addControl(new ol.control.MousePosition({
            projection: 'EPSG:4326',
            coordinateFormat: ol.coordinate.createStringXY(3),
            className: 'custom-mouse-position map-component',
            target: document.getElementById('mapCoordinates'),
            undefinedHTML: '&nbsp;'
          }));

        /* --- User drawing on map --- */
        var drawGeometryFunction = function(coordinates, geometry) {
          if (!geometry) {
            geometry = new ol.geom.Polygon(null);
          }

          var start = coordinates[0];
          var end = coordinates[1];
          geometry.setCoordinates([
            [
              start,
              [start[0], end[1]],
              end,
              [end[0], start[1]],
              start
            ]
          ]);
          return geometry;
        };

        this._draw = new ol.interaction.Draw({
          source: this._mainSource,
          type: 'LineString',
          geometryFunction: drawGeometryFunction,
          maxPoints: 2
        });

        this._draw.addEventListener('drawend', this._handleSelectionDrawEnd.bind(this));

        if(this.area && this.area !== '') {
          var unquotedJSON = this.area;
          var fixedJSON = unquotedJSON.replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2": ');
          var areaObject = JSON.parse(fixedJSON);
          
          var areaFeature = this._coordsToFeature(areaObject);

          var tempSource = new ol.source.Vector({
            wrapX: false,
            noWrap: true
          });

          var tempVector = new ol.layer.Vector({
            source: tempSource,
            style: this.featuresStyle
          });

          this._map.addLayer(tempVector);

          tempSource.addFeature(areaFeature);

          window.setTimeout(function() {
            _this._resizeMapToExtent(tempSource);
            _this._map.removeLayer(tempVector);
          }, 500);

        }

        this._updateMapSize();
        /* --- End user drawing on map --- */
      },

      initialiseMainSource: function() {
        this._mainSource = new ol.source.Vector({
          wrapX: false,
          noWrap: true
        });

        this._mainClusteredSource = new ol.source.Vector({
          wrapX: false,
          noWrap: true
        });

        this.clusterMainClusteredSource = new ol.source.Cluster({
          distance: parseInt(30, 10),
          source: this._mainClusteredSource
        });

        this._vector = new ol.layer.Vector({
          source: this._mainSource,
          style: this.featuresStyle
        });

        this.mainClusteredLayer = new ol.layer.Vector({
          source: this.clusterMainClusteredSource,
          style: this.featuresStyle
        });
      },

      initialisePreviewSource: function() {
        this.previewSource = new ol.source.Vector({
          wrapX: false,
          noWrap: true
        });

        this.previewClusteredSource = new ol.source.Vector({
          wrapX: false,
          noWrap: true
        });

        this.clusterPreviewClusteredSource = new ol.source.Cluster({
          distance: parseInt(30, 10),
          source: this.previewClusteredSource
        });

        this.previewLayer = new ol.layer.Vector({
          source: this.previewSource,
          style: this.featuresStyle
        });

        this.previewClusteredLayer = new ol.layer.Vector({
          source: this.clusterPreviewClusteredSource,
          style: this.featuresStyle
        });
      },

      /* Define style by type */
      featuresStyle: function(feature, resolution){
        var geoName = feature.getGeometry().getType();

        var pointWithMarker = [new ol.style.Style({
          text: new ol.style.Text({
            font: 'normal 24px FontAwesome',
            text: '\uf041',
            textBaseline: 'bottom',
            fill: new ol.style.Fill({
              color: EXTENTS_COLOR
            })
          })
        })];

        if(geoName === 'Point' && feature.get('features')) {
          var size = feature.get('features').length;
          if(size === 1) {
            return pointWithMarker;
          } else if(size > 1) {
            return [new ol.style.Style({
              image: new ol.style.Circle({
                radius: 10,
                stroke: new ol.style.Stroke({
                  color: '#fff'
                }),
                fill: new ol.style.Fill({
                  color: EXTENTS_COLOR
                })
              }),
              text: new ol.style.Text({
                text: size.toString(),
                fill: new ol.style.Fill({
                  color: '#fff'
                })
              })
            })];
          }
        } else {
          if(geoName === 'Point') {
            return pointWithMarker;
          } else {
            return [new ol.style.Style({
              fill: new ol.style.Fill({
                color: 'rgba(255, 255, 255, 0.2)'
              }),
              stroke: new ol.style.Stroke({
                color: EXTENTS_COLOR,
                width: 2
              }),
              image: new ol.style.Circle({
                radius: 3,
                fill: new ol.style.Fill({
                  color: EXTENTS_COLOR
                })
              })
            })]
          }
        }
      },

      /* Utility: Convert object to array */
      _toArray: function(obj) {
        if(obj) {
          return Object.keys(obj).map(function(key) {
            return {
              name: key,
              value: obj[key]
            };
          });
        }
      },

      /* Filter by name */
      _isNotId: function(item) {
        return item.name !== 'id';
      },

      updateLang: function() {
        this.lang = this.lang || navigator.language.substr(0, 2);
      },

      _handlemapMetadataRequest: function(e) {
        if (this.service) {
          this.$.map.classList.remove('reduced');
          this._updateMapSize();
          this._lock = true;
          this.$.ajax.url = this.service;
          this.$.ajax.method = 'POST';
          this.$.ajax.body = JSON.stringify(e.detail);
          this.fire('longActionStartEvent', {
            message: this._localize('loading', this.lang) + '...'
          });
          this.$.ajax.generateRequest();
        }
      },

      _handleResponse: function(request) {
        this.fire('longActionStopEvent', {
          message: this._localize('loading', this.lang) + '...'
        });

        var summaries = request.detail.response;

        if (summaries) {

          this.$.map.classList.add('reduced');

          /* move cart icon */
          var cart = document.querySelector('.cart-bar');
          cart.style.right = '300px';

          var searchResultEvent = {
            summaries: summaries
          };

          var msg = this.lang === 'fr' ? summaries.length + ' éléments trouvés' : 'Found ' + summaries.length + ' elements';

          this.fire('notificationMessageEvent', {
            message: msg
          });
          this.fire('searchResultEvent', searchResultEvent);

          var interval = window.setInterval(this._updateMapSize.bind(this), 50);
          window.setTimeout(function() {
            window.clearInterval(interval);
          }, 350);
        }
      },

      _handleError: function(e) {
        var statusMessage = e.detail.error.message;
        if(!navigator.onLine) statusMessage = 'You are not connected to internet';
        var errorMessage = this._localize('error_occured', this.lang);
        if(statusMessage) errorMessage = errorMessage + ':<p>' + statusMessage + '</p>';
        this.fire('longActionStopEvent', {
          message: this._localize('loading', this.lang) + '...'
        });
        this.fire('errorNotificationMessageEvent', {
          message: errorMessage
        });
      },

      _handleMapEditStartEvent: function(e) {
        var editIcon = e.detail;
        editIcon.style.color = '#f0ad4e';
        this._isDrawMode = true;
        this._map.addInteraction(this._draw);
      },

      _handleMapEditStopEvent: function(e) {
        var editIcon = e.detail;
        editIcon.style.color = '';
        this._isDrawMode = false;
        this._map.removeInteraction(this._draw);
      },

      _handleMapClearAllFeaturesEvent: function() {
        this._clearAllExtents(this._mainSource, true);
        this._clearAllExtents(this._mainClusteredSource, true);
      },

      _handleMapClearSelectionEvent: function(e) {
        var id = e.detail.id;
        if(id) this._removeFeature(id);
      },

      /* Clear all extents for a given source (Secon parameter is a Boolean) */
      _clearAllExtents: function(source, resetZoom) {
        source.clear();
        if(resetZoom) {
          var pan = ol.animation.pan({
            source: (this._map.getView().getCenter()),
            start: +new Date(),
            duration: 300
          });
          var zoom = ol.animation.zoom({resolution: this._map.getView().getResolution(), duration: 300});
          this._map.beforeRender(pan, zoom);

          this._map.getView().setCenter(DEFAULT_CENTER);
          this._map.getView().setZoom(DEFAULT_ZOOM);
        }
      },

      /* Clear all non user-drawn extents on the main source */
      _removeAllButSelectionBox: function() {
        var features = this._mainSource.getFeatures();
        features.forEach(function(item) {
          if(item.getId() !== 'selectionBox') this._mainSource.removeFeature(item);
        }.bind(this));

        features = this._mainClusteredSource.getFeatures();
        features.forEach(function(item) {
          if(item.getId() !== 'selectionBox') this._mainClusteredSource.removeFeature(item);
        }.bind(this));
      },

      /* Remove feature with the specified ID */
      _removeFeature: function(id) {
        var feature = this._mainSource.getFeatureById(id);
        if(feature) this._mainSource.removeFeature(feature);

        feature = this._mainClusteredSource.getFeatureById(id);
        if(feature) this._mainSource.removeFeature(feature);
      },

      /* Add a preview feature on map */
      _handlemapAddPreviewRequest: function(e) {
        var extents = e.detail;
        var features = [];
        var onlyPoints = true;

        extents.forEach(function(extent) {
          var feature = this._spatialExtentToFeature(extent);
          if(feature.getGeometry().getType() !== 'Point') onlyPoints = false;
          features.push(feature);
        }.bind(this));

        if(onlyPoints) {
          this.previewClusteredSource.addFeatures(features);
        } else {
          this.previewSource.addFeatures(features);
        }

        if(!this._isPreviewCleared) {
          this._clearPreview();
        }
      },

      /* Add a feature on map */
      _handlemapAddFeaturesRequest: function(e) {
        var extents = e.detail;
        var features = [];
        var onlyPoints = true;

        extents.forEach(function(extent) {
          var feature = this._spatialExtentToFeature(extent);
          if(feature.getGeometry().getType() !== 'Point') onlyPoints = false;
          features.push(feature);
        }.bind(this));

        if(onlyPoints) {
          this._mainClusteredSource.addFeatures(features);
          this._resizeMapToExtent(this._mainClusteredSource);
        } else {
          this._mainSource.addFeatures(features);
          this._resizeMapToExtent(this._mainSource);
        }
      },

      /* Add a user-drawn selection box (feature) on map */
      _handlemapAddSelectionRequest: function(e) {
        var box = e.detail.box;
        var id = e.detail.id || 'selectionBox';

        this._removeFeature('selectionBox');

        var feature = this._coordsToFeature(box);

        feature.setId(id);

        this._mainSource.addFeature(feature);
        this._selectionBox = feature;

        //this._resizeMapToExtent(this._mainSource);
      },

      /* Convert a JSON spatial extent to Openlayers 3 feature */
      _spatialExtentToFeature: function(spatialExtent) {
        var coords;
        var type = spatialExtent.area.type;
        if(type === 'RECTANGLE_AREA') {
          coords = {
            north: spatialExtent.area.northLatitude,
            south: spatialExtent.area.southLatitude,
            east: spatialExtent.area.eastLongitude,
            west: spatialExtent.area.westLongitude
          };
        } else if (type === 'POINT_AREA') {
          coords = {
            lat: spatialExtent.area.latitude,
            lon: spatialExtent.area.longitude
          };
        }

        var feature = this._coordsToFeature(coords);
        feature.setProperties({
          name: spatialExtent.name,
          description: spatialExtent.description,
          additionalData: spatialExtent.additionalData,
          comment: spatialExtent.comment
        });
        return feature;
      },

      /* Utility: Convert a coordinates object to Openlayers3 feature.
         {north: xx, south: xx, east: xx, west: xx} for rectangle area
         {lon: xxx, lat: xxx} for point */

      _coordsToFeature: function(coords) {
        var obj;
        var l = Object.keys(coords).length;

        if(l === 4) {
          if(coords.north > 85) coords.north = 85;
          if(coords.south < -85) coords.south = -85;

          obj = new ol.geom.Polygon([
            [
              [Number(coords.west), Number(coords.north)],
              [Number(coords.east), Number(coords.north)],
              [Number(coords.east), Number(coords.south)],
              [Number(coords.west), Number(coords.south)],
              [Number(coords.west), Number(coords.north)]
            ]
          ]).transform('EPSG:4326', 'EPSG:900913');

        } else if (l === 2) {
          obj = new ol.geom.Point(ol.proj.transform([Number(coords.lon), Number(coords.lat)], 'EPSG:4326', 'EPSG:900913'));
        }

        var feature = new ol.Feature({
          geometry: obj
        });

        return feature;
      },

      _handleSelectionDrawEnd: function(e) {
        this._removeFeature('selectionBox');

        e.feature.setId('selectionBox');

        this._selectionBox = e.feature;

        var clone = e.feature.clone();
        var extent = clone.getGeometry().getExtent();
        var bottomRight = ol.proj.transform(ol.extent.getBottomRight(extent), 'EPSG:3857', 'EPSG:4326');
        var topLeft = ol.proj.transform(ol.extent.getTopLeft(extent), 'EPSG:3857', 'EPSG:4326');

        var selectionDrawEvent = {
          east: bottomRight[0],
          south: bottomRight[1],
          west: topLeft[0],
          north: topLeft[1]
        };

        this.fire('selectionDrawEvent', selectionDrawEvent);
      },

      /* Resize map to fit all extents on the given source */
      _resizeMapToExtent: function(source) {
        var extent = source.getExtent();
        var pan = ol.animation.pan({
          source: (this._map.getView().getCenter()),
          start: +new Date(),
          duration: 300
        });
        var zoom = ol.animation.zoom({resolution: this._map.getView().getResolution(), duration: 300});
        this._map.beforeRender(pan, zoom);
        this._map.getView().fit(extent, this._map.getSize(), {padding: [0, 0, 0, 0]});
      },

      _handleSearchBarResetEvent: function() {
        this._clearPreview();

        this.$.map.classList.remove('reduced');

        /* move cart icon */
        var cart = document.querySelector('.cart-bar');
        cart.style.right = '0px';

        this._updateMapSize();
      },

      _updateMapSize: function() {
        var interval = window.setInterval(function() {
          this._map.updateSize();
        }.bind(this), 10);

        window.setTimeout(function() {
          window.clearInterval(interval);
        }, 200);
      },

      /* Clear all extents on the 'preview' source */
      _clearPreview: function() {
        var arr = this.previewSource.getFeatures();
        var arr2 = this.previewClusteredSource.getFeatures();
        if(arr.length === 0 && arr2 === 0) {
          this._isPreviewCleared = true;
        } else {
          this._clearAllExtents(this.previewSource, false);
          this._clearAllExtents(this.previewClusteredSource, false);
          this._isPreviewCleared = true;
        }
      },

      /* Set tooltip content */
      _displayFeatureInfo: function(feature) {
        document.body.style.cursor = 'crosshair';
        var info = this.$.info;
        this.tooltipText = {};

        if (feature) {
          this.tooltipText = {
            name: feature.get('name'),
            description: feature.get('description'),
            additionalData: feature.get('additionalData')
          };

          for (var key in this.tooltipText) {
            if (this.tooltipText[key]) info.classList.remove('hidden');
          }
        }
      }

    });
  </script>

</dom-module>
